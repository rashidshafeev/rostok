This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-31T12:03:35.526Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
category/api/categoryApi.ts
category/api/types.ts
category/index.ts
category/types.ts
filter/api/filterApi.ts
filter/api/types.ts
filter/index.ts
filter/types.ts
filter/ui/FilterGroup/FilterGroup.tsx
filter/ui/FilterItem/FilterCheckbox.tsx
filter/ui/index.ts
filter/ui/PriceRange/PriceRange.tsx
order/api/index.ts
order/api/orderApi.ts
order/api/types.ts
order/index.ts
order/types.ts
organization/api/organizationEndpoints.ts
organization/model/Organization.ts
organization/model/organizationsSlice.ts
organization/model/OrganizationsState.ts
price/api/priceApi.ts
price/api/types.ts
price/index.ts
price/types.ts
product/api/productApi.ts
product/api/types.ts
product/index.ts
product/types.ts
review/api/reviewEndpoints.ts
user/api/types.ts
user/api/userApi.ts
user/index.ts
user/lib/cookies.ts
user/lib/hooks/useAuth.ts
user/model/types.ts
user/model/userSlice.ts

================================================================
Files
================================================================

================
File: category/api/categoryApi.ts
================
// src/entities/category/api/categoryApi.ts
import { api } from '@/shared/api/api';

import type { GetCategoryTreeResponse } from './types';

export const categoryApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getCategoryTree: builder.query<GetCategoryTreeResponse, string | null>({
      query: (id) => `api/Products/categoryTree?category_id=${id || ''}`,
      keepUnusedDataFor: 60,
    }),
  }),
});

export const { useGetCategoryTreeQuery } = categoryApi;

================
File: category/api/types.ts
================
import type { CategoryWithImage, CategoryFull } from '@/entities/category';
import type { AdditionalServerResponseData } from '@/shared/types/AdditionalServerResponseData';

export interface GetCategoryTreeResponse extends AdditionalServerResponseData {
  category: CategoryWithImage;
  category_chain: CategoryWithImage[];
  children: CategoryFull[];
}

================
File: category/index.ts
================
export * from './types';
export * from './api/categoryApi';

================
File: category/types.ts
================
import type { ImageSet } from '@/shared/types/ImageSet';

export interface ProductListCategoryChain {
  count: number;
  chain: CategoryWithImage[];
}

export interface CategoryBase {
  id: number;
  name: string;
  slug: string;
}

export interface CategoryWithImage extends CategoryBase {
  image: ImageSet | false;
}

export interface CategoryFull extends CategoryBase {
  image: ImageSet | false;
  product_count: number;
  path: string;
  children?: CategoryFull[];
}

================
File: filter/api/filterApi.ts
================
// src/entities/filter/api/filterApi.ts
import { api } from '@/shared/api/api';

import type { GetFiltersResponse, GetFiltersRequest } from './types';

export const filterApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getFilters: builder.mutation<GetFiltersResponse, GetFiltersRequest>({
      query: (params) => ({
        url: '/api/Products/filters',
        method: 'POST',
        body: params,
      }),
    }),
    getBasicFilters: builder.query<any, void>({
      query: () => '/api/Products/filters/basic',
      keepUnusedDataFor: 60,
    }),
  }),
});

export const { useGetFiltersMutation, useGetBasicFiltersQuery } = filterApi;

================
File: filter/api/types.ts
================
import type { FiltersState } from '../types';
import type { ProductListCategoryChain } from '@/entities/category';
import type { AdditionalServerResponseData } from '@/shared/types/AdditionalServerResponseData';

export interface GetFiltersResponse
  extends FiltersState,
    AdditionalServerResponseData {
  categories: ProductListCategoryChain[];
}

export interface FilterRequestFormat {
  category_id: string | null;
  search: string | null;
  min_price: number | null;
  max_price: number | null;
  brands: number[];
  tags: string[];
  filters: {
    [key: number]: number[];
  };
  min_rating: number | null;
  max_rating: number | null;
}

export interface GetFiltersRequest extends FilterRequestFormat {}

================
File: filter/index.ts
================
export * from './api/filterApi';
export * from './api/types';
export * from './types';

================
File: filter/types.ts
================
import type { BaseFilterParams } from '@/ServerData/Catalog';
import type { ImageSet } from '@/shared/types/ImageSet';

export interface SelectableItem {
  is_active: boolean;
  is_selected: boolean;
}

interface DynamicFilterValue extends SelectableItem {
  id: number;
  text: string;
  color?: string;
  second_color?: string | null;
}

enum FilterType {
  COLOR = 'color',
  TEXT = 'text',
}

export interface DynamicFilter {
  is_active: boolean;
  id: number;
  name: string;
  type: FilterType;
  values: DynamicFilterValue[];
}

export interface PriceFilter {
  min: number;
  max: number;
  current_values?: {
    min: number;
    max: number;
  };
}

export interface TagFilter extends SelectableItem {
  tag: string;
  text_color: string;
  background_color: string;
}

export interface BrandFilter extends SelectableItem {
  id: number;
  name: string;
  image: ImageSet;
  code: string;
}

export interface FiltersState {
  page(arg0: BaseFilterParams, page: any): unknown;
  basics: {
    price: PriceFilter | false;
    tags: TagFilter[];
    brands: BrandFilter[];
    rating: number[];
  };
  dynamics: DynamicFilter[];
  more: DynamicFilter[];
}


export interface PaginationParams {
  page: number | null;
  limit: number;
}


export enum OrderBy {
  popularity = 'popularity',
  price = 'price',
  rating = 'rating',
  discount = 'discount',
}

export enum SortOrder {
  asc = 'asc',
  desc = 'desc',
}

export interface SortingParams {
  orderBy: OrderBy | null;
  sortOrder: SortOrder | null;
}

================
File: filter/ui/FilterGroup/FilterGroup.tsx
================
import { memo } from 'react';

import { Accordion, AccordionDetails, AccordionSummary } from '@mui/material';

import { ArrowIcon } from '@/shared/ui/icons';

interface FilterGroupProps {
  title: string;
  children: React.ReactNode;
  defaultExpanded?: boolean;
  className?: string;
}

export const FilterGroup = memo(
  ({
    title,
    children,
    defaultExpanded = true,
    className = '',
  }: FilterGroupProps) => {
    return (
      <Accordion
        defaultExpanded={defaultExpanded}
        className={className}
        sx={{
          boxShadow: 'none',
          '&:before': { display: 'none' },
          margin: 0,
        }}
        disableGutters
      >
        <AccordionSummary
          expandIcon={<ArrowIcon className="!w-4 !h-4 rotate-[180deg]" />}
          sx={{ padding: 0, flexDirection: 'row-reverse', gap: '8px' }}
        >
          <span className="font-semibold text-colBlack">{title}</span>
        </AccordionSummary>
        <AccordionDetails sx={{ padding: 0 }}>{children}</AccordionDetails>
      </Accordion>
    );
  }
);

FilterGroup.displayName = 'FilterGroup';

================
File: filter/ui/FilterItem/FilterCheckbox.tsx
================
// src/entities/filter/ui/FilterItem/FilterCheckbox.tsx

import { memo } from 'react';

import { FormControlLabel, Checkbox } from '@mui/material';

interface FilterCheckboxProps {
  label: React.ReactNode;
  checked: boolean;
  onChange: () => void;
  disabled?: boolean;
  className?: string;
}

export const FilterCheckbox = memo(
  ({
    label,
    checked,
    onChange,
    disabled = false,
    className = '',
  }: FilterCheckboxProps) => {
    return (
      <FormControlLabel
        className={`m-0 ${className} ${disabled ? 'opacity-40' : ''}`}
        control={
          <Checkbox
            checked={checked}
            onChange={onChange}
            disabled={disabled}
            style={{
              color: '#15765B',
              padding: '5px',
            }}
          />
        }
        label={<div className="text-sm font-medium text-colBlack">{label}</div>}
      />
    );
  }
);

FilterCheckbox.displayName = 'FilterCheckbox';

================
File: filter/ui/index.ts
================
export * from './FilterGroup/FilterGroup';
export * from './FilterItem/FilterCheckbox';
export * from './PriceRange/PriceRange';

================
File: filter/ui/PriceRange/PriceRange.tsx
================
// src/entities/filter/ui/PriceRange/PriceRange.tsx

import { memo, useEffect, useState } from 'react';
import { Slider, Box } from '@mui/material';
import { useDebounce } from 'react-use';
import { CTextField } from '@/shared/ui/inputs';

interface PriceRangeProps {
  min: number;
  max: number;
  value: [number, number];
  onChange: (value: [number, number]) => void;
  className?: string;
}

export const PriceRange = memo(({
  min,
  max,
  value,
  onChange,
  className = ''
}: PriceRangeProps) => {
  const [localValue, setLocalValue] = useState(value);

  // Debounce value changes
  useDebounce(
    () => {
      if (localValue[0] !== value[0] || localValue[1] !== value[1]) {
        onChange(localValue);
      }
    },
    1000,
    [localValue]
  );

  // Update local value when props change
  useEffect(() => {
    setLocalValue(value);
  }, [value]);

  return (
    <div className={className}>
      <Slider
        value={localValue}
        onChange={(_, newValue) => setLocalValue(newValue as [number, number])}
        min={min}
        max={max}
        sx={{ color: '#15765B' }}
      />
      
      <Box className="grid grid-cols-2 gap-3">
        <CTextField
          label={`от ${min}`}
          type="number"
          value={localValue[0]}
          onChange={(e) => setLocalValue([Number(e.target.value), localValue[1]])}
        />
        <CTextField
          label={`до ${max}`}
          type="number"
          value={localValue[1]}
          onChange={(e) => setLocalValue([localValue[0], Number(e.target.value)])}
        />
      </Box>
    </div>
  );
});

PriceRange.displayName = 'PriceRange';

================
File: order/api/index.ts
================
export * from './orderApi';
export * from './types';

================
File: order/api/orderApi.ts
================
import { api } from '@/shared/api/api';
import type { GetUserOrdersResponse } from './types';

export interface ErrorResponse { // Added export
  data?: {
    err_code?: string;
  };
}

export const orderApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getCitiesAndRegions: builder.query({
      query: () => '/api/Location/full',
      staleTime: 60000,
    }),
    sendOrder: builder.mutation({
      query: (order) => ({
        url: '/api/Products/sendOrder',
        method: 'POST',
        body: order,
      }),
      invalidatesTags: (result, error, order) => [
        { type: 'Order'},
        // ...order.products.map((product) => ({
        //   type: 'Product',
        //   id: product.id,
        // })),
      ],
    }),
    cancelOrder: builder.mutation<
      { success: string },
      { order_number: string; reason: string }
    >({
      query: (data) => ({
        url: '/api/ProductOrders/cancel/order',
        method: 'POST',
        body: data,
      }),
      invalidatesTags: [
        { type: 'Order', id: 'LIST' },
        { type: 'Order', id: 'FILTERS' },
      ],
    }),
    getUserOrders: builder.query<GetUserOrdersResponse, void>({
      query: () => '/api/Products/orders/get',
      providesTags: (result) =>
        result
          ? [{ type: 'Order', id: 'LIST' }]
          : [{ type: 'Order', id: 'LIST' }],
      refetchOnMountOrArgChange: true,
    }),
    getOrdersFilters: builder.query({
      query: () => '/api/Products/orders/filters',
      providesTags: (result) =>
        result
          ? [{ type: 'Order', id: 'FILTERS' }]
          : [{ type: 'Order', id: 'FILTERS' }],
      refetchOnMountOrArgChange: true,
    }),
    sendFeedback: builder.mutation({
      query: (feedback) => ({
        url: '/api/Products/feedback',
        method: 'POST',
        body: feedback,
      }),
    }),
    repeatOrder: builder.mutation<
      { success: string; new_order_number: string },
      { order_number: string }
    >({
      query: (data) => ({
        url: '/api/ProductOrders/repeat/order',
        method: 'POST',
        body: data,
      }),
      invalidatesTags: [
        { type: 'Order', id: 'LIST' },
        { type: 'Order', id: 'FILTERS' },
        { type: 'Cart', id: 'LIST' },
      ],
    }),
    createPDFOrder: builder.mutation<
      { success: string; file: Blob },
      { order_number: string }
    >({
      query: (data) => ({
        url: '/api/ProductOrders/create/pdf/order',
        method: 'POST',
        body: data,
        responseHandler: async (response) => {
          const blob = await response.blob();
          return { success: 'ok', file: blob };
        },
      }),
    }),
  }),
});

export const {
  useGetCitiesAndRegionsQuery,
  useSendOrderMutation,
  useCancelOrderMutation,
  useGetUserOrdersQuery,
  useGetOrdersFiltersQuery,
  useSendFeedbackMutation,
  useRepeatOrderMutation,
  useCreatePDFOrderMutation,
} = orderApi;

================
File: order/api/types.ts
================
import type { Order } from '../types';
import type { AdditionalServerResponseData } from '@/shared/types/AdditionalServerResponseData';

export interface GetUserOrdersResponse extends AdditionalServerResponseData {
  data: Order[];
}

================
File: order/index.ts
================
export * from './api';
export * from './types';

================
File: order/types.ts
================
import type { Product } from '@/entities/product';

export interface OrderStatus {
  name: string;
  background_color: string;
  text_color: string;
}

export interface OrderProduct extends Product {
  quantity: number;
}

export interface OrderTotals {
  amount: number;
  quantity: number;
  discount: number;
}

export interface Order {
  order_number: string;
  date: string;
  status: OrderStatus;
  items: OrderProduct[];
  total: OrderTotals;
}

================
File: organization/api/organizationEndpoints.ts
================
import { api } from '@/shared/api/api';

export const organizationEndpoints = api.injectEndpoints({
  endpoints: (builder) => ({
    getOrgSuggestions: builder.mutation({
      query: (data) => ({
        url: `/api/Company/suggest?query=${data}`,
        method: 'GET',
      }),
    }),
    getOrganizations: builder.query({
      query: () => '/api/Company/list',
      staleTime: 60000,
      providesTags: (result) =>
        result
          ? [
              { type: 'Organization', id: 'LIST' },
              ...result.data.map(({ id }) => ({ type: 'Organization', id })),
            ]
          : [{ type: 'Organization', id: 'LIST' }],
    }),
    addOrganization: builder.mutation({
      query: (data) => ({
        url: '/api/Company/new',
        method: 'POST',
        body: data,
      }),
      invalidatesTags: [{ type: 'Organization', id: 'LIST' }],
    }),
    deleteOrganization: builder.mutation({
      query: (id) => ({
        url: '/api/Company/delete',
        method: 'POST',
        body: { id },
      }),
      invalidatesTags: (result, error, { id }) => [
        { type: 'Organization', id: 'LIST' },
        { type: 'Organization', id },
      ],
    }),
    editOrganization: builder.mutation({
      query: (data) => ({
        url: '/api/Company/update',
        method: 'POST',
        body: data,
      }),
      invalidatesTags: (result, error, { id }) => [
        { type: 'Organization', id: 'LIST' },
        { type: 'Organization', id },
      ],
    }),
  }),
});

export const {
  useGetOrgSuggestionsMutation,
  useGetOrganizationsQuery,
  useAddOrganizationMutation,
  useDeleteOrganizationMutation,
  useEditOrganizationMutation,
} = organizationEndpoints;

================
File: organization/model/Organization.ts
================
export interface Organization {
  inn: number;
  kpp: number;
  name: string;
  yurAddress: string;
  faqAddress: string;
  ogrn: number;
  rasSchet: number;
  bikBanka: number;
  korrSchet: number;
  bankName: string;
}

================
File: organization/model/organizationsSlice.ts
================
import { createSlice } from '@reduxjs/toolkit';

import type { OrganizationsState } from '@/entities/organization/model/OrganizationsState';

const initialState: OrganizationsState = {
  organizations: [],
};

export const organizationsSlice = createSlice({
  name: 'organizations',
  initialState,
  reducers: {
    addOrganization: (state, action) => {
      state.organizations.push({ ...action.payload });
    },
    deleteOrganization: (state, action) => {
      const organization = state.organizations.find(
        (org) => org.inn === action.payload.inn
      );

      if (organization) {
        state.organizations = state.organizations.filter(
          (org) => org.inn !== action.payload.inn
        );
      }
    },
    updateOrganization: (state, action) => {
      const organization = state.organizations.find(
        (org) => org.inn === action.payload.organization.inn
      );
      Object.assign(organization, action.payload.data);
    },
  },
});

export const { addOrganization, deleteOrganization, updateOrganization } =
  organizationsSlice.actions;
export default organizationsSlice.reducer;

================
File: organization/model/OrganizationsState.ts
================
import type { Organization } from '@/entities/organization/model/Organization';

export interface OrganizationsState {
  organizations: Organization[];
}

================
File: price/api/priceApi.ts
================
import { api } from '@/shared/api/api';

import type {
  GetCartItemPriceRequest,
  GetCartItemPriceResponse,
} from './types';

export const priceApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getCartItemPrice: builder.mutation<
      GetCartItemPriceResponse,
      GetCartItemPriceRequest
    >({
      query: (data) => ({
        url: '/api/Products/price/get',
        method: 'POST',
        body: data,
      }),
      invalidatesTags: [
        { type: 'Cart', id: 'LIST' },
        { type: 'User', id: 'DATA' },
      ],
    }),
  }),
});

export const { useGetCartItemPriceMutation } = priceApi;

================
File: price/api/types.ts
================
import type { PriceType } from '../types';
import type { AdditionalServerResponseData } from '@/shared/types/AdditionalServerResponseData';

export interface GetCartItemPriceResponse extends AdditionalServerResponseData {
  data: null | {
    item_id: number;
    price: PriceType;
  };
  total_amount: number;
  total_quantity: number;
}

export interface GetCartItemPriceRequest {
  item_id: number;
  quantity: number;
}

================
File: price/index.ts
================
export * from './api/priceApi';
export * from './types';

================
File: price/types.ts
================
export interface Currency {
  code: string;
  title: string;
  symbol: string;
}

type Discount = {
  price: number;
  percent: number;
  discount_amount: number;
  reason: string | null;
};

export interface PriceType {
  base: number | null;
  final: number;
  discount: Discount | null;
  unit: string;
  currency: Currency | null;
  total?: number;
}

================
File: product/api/productApi.ts
================
// src/entities/product/api/productApi.ts
import { api } from '@/shared/api/api';

import type { GetProductResponse } from '@/entities/product/GetProduct';
import type {
  GetVariantsResponse,
  GetVariantsRequest,
} from '@/entities/product/GetVariants';

export const productApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getProduct: builder.query<GetProductResponse, string>({
      query: (id) => `api/Products/item?id=${id}`,
      keepUnusedDataFor: 60,
      providesTags: (result, error, id) => [{ type: 'Product', id }],
    }),
    getVariants: builder.mutation<GetVariantsResponse, GetVariantsRequest>({
      query: (params) => ({
        url: '/api/Products/variants',
        method: 'POST',
        body: params,
      }),
    }),
  }),
});

export const { useGetProductQuery, useGetVariantsMutation } = productApi;

================
File: product/api/types.ts
================
import type { BaseFilterParams } from '../../../entities/filter/common/BaseFilterParams';
import type { ProductGroup } from '../../types/ProductGroup/ProductGroup';
import type { PaginationParams } from '../filter/common/PaginationParams';
import type { SortingParams } from '../filter/common/SortingParams';
import type { Product } from '../types';
import type { AdditionalServerResponseData } from '@/shared/types/AdditionalServerResponseData';

export interface GetVariantsResponse extends AdditionalServerResponseData {
  count: number;
  data: Product[];
}

export interface GetVariantsRequest
  extends BaseFilterParams,
    SortingParams,
    PaginationParams {}

export interface GetProductResponse extends AdditionalServerResponseData {
  data: ProductGroup;
}

================
File: product/index.ts
================
export * from './api/productApi';
export * from './api/types';
export * from './types';

================
File: product/types.ts
================
import type { CategoryBase } from '@/entities/category';
import type { PriceType } from '@/entities/price';
import type { DateType } from '@/shared/types/DateType';
import type { ImageSet } from '@/shared/types/ImageSet';

export interface Tag {
  text: string;
  text_color: string;
  background_color: string;
}

export interface Brand {
  id: number;
  name: string;
  files?: ImageSet[];
}
export interface ModificationAttribute {
  id: number;
  value: number;
  sorting: number;
  name: string;
  type: string;
  text: string;
  color?: string;
  second_color?: string;
}

export interface Currency {
  code: string;
  title: string;
  symbol: string;
}

export interface AvailabilityState {
  stock: number;
  preorder: DateType | null;
}
export interface Product {
  id: number;
  relevance: number;
  groupId: number;
  sku: number;
  slug: string;
  name: string;
  groupName: string;
  fullName: string;
  availability: AvailabilityState;
  description: string;
  files: ImageSet[];
  category: CategoryBase;
  price: PriceType;
  tags: Tag[] | false;
  brand: Brand | false;
  attributes: ModificationAttribute[];
}

export interface Review {
  rating: number;
  total_count: number;
  total_count_text: string;
  list: any[]; // Adjust the type of `list` based on the actual data structure
}

export interface Attribute {
  id: number;
  name: string;
  type: string;
  values: AttributeValue[];
}

export interface AttributeValue {
  type: string;
  text: string;
}

export interface ProductGroup {
  name: string;
  sku: number;
  slug: string;
  description: string;
  attributes: Attribute[];
  category_chain: CategoryBase[];
  variants: Product[];
  reviews: Review;
}

================
File: review/api/reviewEndpoints.ts
================
// reviewEndpoints.js
import { api } from '@/shared/api/api';

export const reviewEndpoints = (builder) => ({
  submitReview: builder.mutation({
    query: (data) => ({
      url: '/api/Products/review/set',
      method: 'POST',
      body: data,
    }),
  }),
});

// Export hooks for review endpoints
export const { useSubmitReviewMutation } = api.injectEndpoints({
  endpoints: reviewEndpoints,
});

================
File: user/api/types.ts
================
import type { User } from '../model/types';
import type { AdditionalServerResponseData } from '@/shared/types/AdditionalServerResponseData';


export interface CartData {
  items_count: number;
  quantity: number;
}

export interface FavoritesData {
  items_count: number;
}

export interface ComparisonData {
  items_count: number;
}

export interface GetUserDataResponse extends AdditionalServerResponseData {
  user: User;
  cart: CartData;
  favorites: FavoritesData;
  comparison: ComparisonData;
}

================
File: user/api/userApi.ts
================
import { api } from '@/shared/api/api';

import type { GetUserDataResponse } from './types';

export const userApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getUserData: builder.query<GetUserDataResponse, void>({
      query: () => ({
        url: '/api/UserData/get',
        method: 'GET',
      }),
      providesTags: [{ type: 'User', id: 'DATA' }],
      keepUnusedDataFor: 0,
      refetchOnFocus: true,
    }),
    changeUserData: builder.mutation({
      query: (data) => ({
        url: '/api/Profile/saveInfo',
        method: 'POST',
        body: data,
      }),
      invalidatesTags: [{ type: 'User', id: 'DATA' }],
    }),
  }),
});

export const { useGetUserDataQuery, useChangeUserDataMutation } = userApi;

================
File: user/index.ts
================
// src/entities/user/index.ts
export * from './model/types';
export * from './model/userSlice';
export * from './api/userApi';
export * from './lib/cookies';

================
File: user/lib/cookies.ts
================
export const COOKIE_TOKEN_KEY = 'auth_token';

export const getTokenFromCookies = (): string | null => {
  // Implementation of getting token from cookies
  return (
    document.cookie.replace(
      /(?:(?:^|.*;\s*)auth_token\s*\=\s*([^;]*).*$)|^.*$/,
      '$1'
    ) || null
  );
};

export const saveTokenToCookies = (token: string): void => {
  document.cookie = `${COOKIE_TOKEN_KEY}=${token}; path=/; max-age=2592000`; // 30 days
};

export const removeTokenFromCookies = (): void => {
  document.cookie = `${COOKIE_TOKEN_KEY}=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT`;
};

================
File: user/lib/hooks/useAuth.ts
================
// src/entities/user/hooks/useAuth.ts
import { useSelector } from 'react-redux';

import type { RootState } from '@/app/providers/store';

export const useAuth = () => {
  const {
    isAuthenticated,
    token,
    data: user,
  } = useSelector((state: RootState) => state.user);

  return {
    isAuthenticated,
    token,
    user,
  };
};

================
File: user/model/types.ts
================
export interface User {
  name: string;
  photo: string | null;
  phone: string;
  email: string;
  gender: string;
  date_of_birth: string | null;
}

export interface UserState {
  token: string | null;
  isAuthenticated: boolean;
  isInitialized: boolean;
  data: User | null;
}

================
File: user/model/userSlice.ts
================
// src/entities/user/model/userSlice.ts
import { createSlice } from '@reduxjs/toolkit';

import {
  getTokenFromCookies,
  saveTokenToCookies,
  removeTokenFromCookies,
} from '../lib/cookies';

import type { User, UserState } from './types';
import type { PayloadAction } from '@reduxjs/toolkit';

const initialState: UserState = {
  token: null,
  isAuthenticated: false,
  isInitialized: false,
  data: null,
};

export const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    initializeAuth: (state) => {
      const token = getTokenFromCookies();
      state.token = token;
      state.isAuthenticated = !!token;
      state.isInitialized = true;
    },
    setToken: (state, action: PayloadAction<string | null>) => {
      if (action.payload) {
        saveTokenToCookies(action.payload);
        state.token = action.payload;
        state.isAuthenticated = true;
      } else {
        removeTokenFromCookies();
        state.token = null;
        state.isAuthenticated = false;
        state.data = null;
      }
    },
    setUserData: (state, action: PayloadAction<User>) => {
      state.data = action.payload;
    },
  },
});

export const { initializeAuth, setToken, setUserData } = userSlice.actions;
export default userSlice.reducer;
